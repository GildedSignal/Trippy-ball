# Implementation Documentation (Current)

Last synchronized with source on **February 17, 2026**.

## Mandatory Documentation Rule
Any agent modifying this project must update docs in the same task.

Required:
1. `/Users/julien_laurent/Projets cursor/Small projects/Trippy ball 5/README.md`
2. `/Users/julien_laurent/Projets cursor/Small projects/Trippy ball 5/PROGRESS.md`
3. `/Users/julien_laurent/Projets cursor/Small projects/Trippy ball 5/DOCUMENTATION.md`
4. `/Users/julien_laurent/Projets cursor/Small projects/Trippy ball 5/SYSTEM_ARCHITECTURE.md`
5. `/Users/julien_laurent/Projets cursor/Small projects/Trippy ball 5/TECHNICAL_DESIGN.md`

## 1. Runtime Summary
The app renders a 3D point cloud where intensity is derived from:
- angular term: spherical harmonics `Y_l^m(theta, phi)`
- radial term: hydrogenic radial function `R_nl(r; Z)` in Bohr-radius units
- time evolution: hydrogen-like energy levels with coherent phase evolution

Runtime path is Metal-native for presentation/UI and hybrid CPU+GPU for scheduled intensity updates.
The rendered output is the density of a coherent two-state superposition (`|psi|^2`) controlled by
`n/l/m`, `n2/l2/m2`, `mix`, `relative_phase`, `z`, and `time_factor (fs/s)`.

## 2. Main Loop (`src/main.rs`)
Per frame:
1. Read UI/camera input.
2. Update UI-driven params.
3. Compute monotonic `sim_time` from `simulation_start`.
4. Call `MetalRenderer::update_points` (scheduler + CPU/GPU updates).
5. Call `MetalRenderer::render` (native Metal present path).

Startup guard exits on non-macOS targets.
Logging now uses local telemetry macros (`src/telemetry.rs`) instead of `log/env_logger`.

## 3. Compute Model

### CPU
- Entry: `math::evaluate_wavefunction_batch`
- Rayon chunked parallel processing
- x86_64 AVX2/AVX-512 branches when available
- thread-local Legendre cache in `math/spherical.rs`
- low-`l` normalization table in `math/kernel_tables.rs`

### GPU Scheduled Evaluator
- Entry: `render::GpuWavefunctionEvaluator`
- Metal compute kernel from `render_metal/shaders/wavefunction.metal`
- range dispatch (`start_index`, `compute_count`)
- SoA evaluator buffers (`positions`, `intensities`) in shared Metal memory
- uploads shared low-`l` normalization table generated by `math/kernel_tables.rs`
- runtime path uses no-readback dispatch queue (`enqueue_compute_range_no_readback` + `poll_completed_no_readback`)
- CPU fallback ranges are patched directly into GPU intensity storage (`upload_intensity_range`)
- readback queue is retained for parity/benchmark flows
- stale-frame tolerant polling via `poll_completed`
- Metal kernel now clamps origin/pole angular handling so `phi` remains defined (`0`) when `x/y` are near zero

### Scheduler
- Entry: `sim::AdaptiveScheduler`
- defaults: `target_fps=60`, `max_stale_frames=2`, `block_size=65536`, `cpu_threads=8`
- EWMA throughput model for GPU/CPU split
- automatic approximation mode under sustained budget misses
- approximation->exact recovery now requires a sustained stable-frame streak (hysteresis)
- dynamic block-size/quality retuning under pressure
- runtime compute ranges are block-prioritized by coarse visibility scores from `PointCloud` when culling data is valid

## 4. Native Metal Render Path
- Entry: `render_metal::MetalRenderer`
- `render_metal::surface` binds `CAMetalLayer` to the window
- `render_metal::context` builds native render + cull/indirect compute pipelines
- wavefunction intensity compute is completed before render in `MetalRenderer::update_points`
- native render context now separates static position and dynamic intensity buffers:
  - positions upload on point-count/capacity changes
  - intensity source prefers evaluator shared buffer (fallback upload path retained)
  - runtime compute effective count is coupled to native drawable cap so scheduler work does not exceed renderable points
- native frame path includes:
  - compute culling pass (`cull_points`)
  - compute indirect-args finalize pass (`finalize_cull`)
  - direct use of evaluator-owned GPU intensity buffer when available
  - point draw via `draw_primitives_indirect`
  - egui draw pass via `render_metal::metal_painter`
  - drawable present

## 5. Point Count Caps and Tuning
- Requested count comes from UI.
- Effective count is clamped in `sim/data_layout.rs`.
- Native drawable submission has separate cap in `render_metal/context.rs`.

Env controls:
- `TRIPPY_BALL_MAX_RENDER_POINTS`: default `5000000`, clamp `1000..20000000`
- `TRIPPY_BALL_NATIVE_SHADOW_POINTS`: default `5000000`, clamp `1000..5000000`
- effective runtime compute cap uses `min(TRIPPY_BALL_MAX_RENDER_POINTS, TRIPPY_BALL_NATIVE_SHADOW_POINTS)`

## 6. Diagnostics and Benchmarks
UI/runtime diagnostics include:
- frame/gpu/cpu ms
- scheduler block size and quality
- queue depth and stale frames
- approximation mode flag
- worker utilization
- native cull/visibility/truncation stats
- sampled intensity min/max/avg/zero estimates (for low overhead at high point counts)

Additional validation coverage includes:
- `math::tests::heavy_parallel_workload_engages_cpu_workers` (8-thread pool engagement under heavy chunked workload)
- `render::gpu_wavefunction::tests::gpu_matches_cpu_reference_spherical_grid` (CPU/GPU parity on representative spherical-coordinate grids across `l<=5`)
- `ui::input_bridge::tests::*` (event mapping/consumption semantics for local winit->egui bridge)
- `memory::pod::tests::*` (POD zero/init and unaligned-read safety checks)
- `telemetry::tests::*` (log level parsing behavior for local telemetry layer)

CLI benchmarks:
- `--benchmark` (quick)
- `--benchmark-stress`
- `--benchmark-soak` (includes per-stage breakdown)
- `--benchmark-soak-30m` / `--benchmark-soak-timed` (30-minute target by default; staged load profile by wall-clock duration)
- `--benchmark-cap-sweep` (effective-cap sensitivity sweep; override caps with `TRIPPY_BALL_CAP_SWEEP_CAPS=2000000,5000000,...`)
- `--benchmark-cap-pair-sweep` (paired simulation-cap vs shadow-cap sweep using coupled effective cap)

Benchmark env controls:
- `TRIPPY_BALL_SOAK_DURATION_SECS` for timed soak mode (default `1800`, clamp `10..43200`)
- `TRIPPY_BALL_CAP_SWEEP_CAPS` for cap sweep list (comma-separated integer caps)
- `TRIPPY_BALL_CAP_PAIR_SWEEP_SIM_CAPS` for paired sweep simulation caps
- `TRIPPY_BALL_CAP_PAIR_SWEEP_SHADOW_CAPS` for paired sweep shadow caps

Automated CI:
- `.github/workflows/ci.yml` runs check/test gates on push/PR and a macOS benchmark smoke run.

## 7. Scientific Guardrails
- Canonical contract: `docs/scientific_contract.md`
- Dedicated scientific integration tests in `tests/`:
  - `scientific_cpu_invariants.rs` (normalization, orthogonality, reference-consistency, stationarity)
  - `scientific_gpu_parity_pr.rs` (PR-tier CPU/GPU parity)
  - `scientific_gpu_parity_nightly.rs` (nightly expanded CPU/GPU parity sweep)
  - `scientific_docs_consistency.rs` (doc-claim consistency gate)
- Sample level selector:
  - `TRIPPY_BALL_SCI_SAMPLE_LEVEL=pr|nightly` (default `pr`)
- Optional remediation owner override:
  - `TRIPPY_BALL_SCI_OWNER=<github-handle>`
- Automated remediation workflow:
  - `scripts/scientific/report.sh` generates JSON/Markdown failure artifacts
  - `scripts/scientific/open_or_update_issue.sh` opens/updates `scientific-regression` GitHub issues

## 8. Dependency Baseline

Runtime app direct deps include `winit`, `egui`, `glam`, `rayon`.
macOS-specific direct deps include `metal`, `core-graphics-types`.

Removed direct dependencies include:
- `egui-winit` (replaced by `src/ui/input_bridge.rs`)
- `bytemuck` (replaced by `src/memory/pod.rs`)
- `num-complex` (replaced by explicit complex arithmetic in `src/math/`)
- `rand` (replaced by deterministic local PRNG in benchmark generation)
- `log` and `env_logger` (replaced by `src/telemetry.rs`)
- `criterion` bench target and standalone `math_harness` crate
- direct `objc` dependency (Objective-C usage now goes through `metal::objc`)
